/*!
	\page gol-tutorial.html tutorial
	
	\title Game of Life Tutorial
	
	\image intro_picture.png
	
	\chapter Introduction
	
		This tutorial is about the famous cellular automaton by John Conway - referred to as  \l {https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life}{Conway's Game of Life}.
		It will concentrate on implementing a basic version of this simulation but will also partly cover topics like \e {"multiple scenes"}, \e {organizing UI elements on the screen} and \e {entitiy communication}.
		
		\chapter New Project & the Basics
		
		Create a new Empty V-Play Project with the name \b {Game_Of_Life}. Inside the qml directory of your project, create the following new folders: \b {entities} & \b {scenes} (which we will need later).
		
		So lets talk briefly about the basic idea and facts of \e {Game of Life} (for more detailed infos, visit the link above).
		
		\list 1
			\li We want to show a two-dimensional board, consisting of cells (one per position x/y)
			\li A cell has a position on the board (x/y coordinate), has two possible states (dead or alive) and each state is displayed differently
			\li A cell changes its state depending on its current one and the ones of its surrounding neighbours (more on that later)
			\li The simulation happens in steps. Changes of cells happen only in between steps
			\li We want to define how many steps we want to simulate
			\li The board needs an initial setup of living/dead cells
		\endlist
		
		This already tells us that there are some settings to be adjusted before the actual simulation can start. Therefore it makes sense to start with how we want to split up the game buy using multiple scens.
	
	\chapter Multiple Scenes Setup
	
		\section1 The Base
		
			When having multiple versions of the same type, it is always a good idea to think about characteristics they all have in common. If there are enough, its worth creating a common base version.
			In our case we want to have two different scenes. One as the menu where we can define all the different settings for our simulation and a second one for the simulation itself.
			
			Lets start by adding a new scene under the \e {scenes} folder - namely \underline {SceneBase.qml}.
			
			\qml
				import VPlay 2.0
				import QtQuick 2.0

				// The base for our scenes
				Scene {
					id: sceneBase
					// The "logical size" - the scene content is auto-scaled to match the GameWindow size
					width: 320
					height: 480

					// By default, set the opacity to 0 - this will be changed from the Main.qml with PropertyChanges
					opacity: 0
					// We set the visible property to false if opacity is 0 because the renderer skips invisible items, this is an performance improvement
					visible: opacity > 0
					// If the scene is invisible, we disable it
					enabled: visible

					// Background
					Rectangle {
						anchors.fill: parent.gameWindowAnchorItem
						color: "#47688e"
					}
				}
			\endqml
			
			So what do we already see:
			
			\list
				\li width/height is common since we normally want all scens to have the same size
				\li opacity/visible/enabled all contribute to the behaviour we want when switching between scenes (details in comments)
				\li We have a rectangle as background, spanning the whole scene. This would also be possible with an image
			\endlist
			
		\section1 The Menu
		
			Now its time for the menu scene, which will not only be the place where we define the conditions for our simulation, but also the thing we see before and after a simulation. 
			Add again a new scene int \e {scenes} folder and name it \underline {MenuScene.qml}.
		
			\qml
				import VPlay 2.0
				import QtQuick 2.0

				// The Menu Scene
				SceneBase {
					id: menuScene

					// Headline with the name of the app
					Text {
						anchors.horizontalCenter: parent.horizontalCenter
						y: 30
						font.pixelSize: 30
						color: "#e9e9e9"
						text: "The Game of Life"
					}
				}
			\endqml
			
			Not yet much to see her but this will change soonish. First is to note that we do not use "Scene" for our type definition but instead our own defined type e\ {SceneBase} - which is important because else our base class would't make too much sense ;)
			Also note that we did not have to add an additonal import to be able to use our own type - this is due to it being in the same folder as this file. We will later see how it looks like to import something.
			Beside these things, we added a nice headline for our app, prominently spelling its name.
			
		\section1 The Game Scene
			
			The last scene we add is the one where our simulation will take place. Add it as before under \e {scenes} with the name \e {GameScene.qml}.
			
			\qml
				import VPlay 2.0
				import QtQuick 2.0

				// The Game Scene
				SceneBase {
					id: gameScene

					property bool simulationRunning: false

					sceneAlignmentY: "top"
					sceneAlignmentX: "left"

					// The entitiy  manager which will store all cells of our board
					EntityManager {
						 id: cellBoardEntityManager
						 entityContainer: gameScene
					}

				}
			\endqml
			
			Some new things here to mention. The bool property will be needed in the future to tell us if the simulation is still running. The EntitiyManager is not yet used but will be needed when we create our cells for the board.
			
		\section1 Bringing them together
			
			All basic scene versions are in place, so its time to put them to use. Also we can now define our \e {Main.qml} - which got auto created with new project.
			
			\qml
				import VPlay 2.0
				import QtQuick 2.0

				import "scenes"

				GameWindow {
					id: gameWindow

					screenWidth: 960
					screenHeight: 640

					property int setupLivingCells: 2
					property int setupSimulationSteps: 1
					property int currentSimulationStep: 0

					MenuScene {
						id: menuScene
					}

					GameScene {
						id: gameScene
					}
				}
			\endqml
			
			First thing to note is the additional import, so we have access to our defined scenes. In preperation we also added three integer properties:
			
			\list
				\li \e {setupLivingCells} represents the number of cells which got setup for the beginning of the simulation.
				\li \e {setupSimulationSteps} represents the number of simulation steps we want to perform
				\li \e {currentSimulationStep} is there to keep track of how many simulation steps we did.
			\endlist
			
			And last but not least, we have the definitions for our newly created scenes. 
			
		\section1 Controlling visibility
			
			So our scenes are in place but as for now, there is no activity possible. We want to switch between the scenes and for this we need the functionality itself and something to trigger it. 
			For the functionality, we already added some properties to the \e {SceneBase}, which we will put to use now. Add the following to your \e {Main.qml}:
			
			\qml
				...
				
				GameWindow {
					...
					
					// Default state is menu -> Default scene is menuScene
					state: "menu"
					activeScene: menuScene

					// State machine, takes care of reversing the PropertyChanges when changing the state
					states: [
						State {
							name: "menu"
							PropertyChanges {target: menuScene; opacity: 1}
							PropertyChanges {target: gameWindow; activeScene: menuScene}
						},
						State {
							name: "game"
							PropertyChanges {target: gameScene; opacity: 1}
							PropertyChanges {target: gameWindow; activeScene: gameScene}
						}
					]
				}
			\endqml
			
			The solution is to use StateMachine. The GameWindow has the property \e {state} which we set to \e {menu} because the menuScene is the place where we want to start. The following code defines what should happen on the specific state changes. It will be browsed through and do what is set up.
			This is on one hand, to change the opacity of the scene where we wanna go (which through the set up properties also implicitly changes \e {visible} and \e {enabled}). On the other hand we change the \e {activeScene} property to the one we want.
			
		\section1 One Button to rule them all
			
			Now that the functionality to switch scenes is in place, we need UI elements to trigger them. Since we will several buttons (not only for switching), we should create a reusable one. Add a \e {MenuButton.qml} file to the \e {entities} folder, with the following content:
			
			\qml
				import QtQuick 2.0

				Rectangle {
					id: button

					// The horizontal margin from the Text element to the Rectangle at both the left and the right side
					property int paddingHorizontal: 10
					// The vertical margin from the Text element to the Rectangle at both the top and the bottom side
					property int paddingVertical: 5
					// access the text of the Text component
					property alias text: buttonText.text

					// this handler is called when the button is clicked.
					signal clicked

					// This will be the default size, it is same size as the contained text + some padding
					width: buttonText.width + paddingHorizontal * 2
					height: buttonText.height + paddingVertical * 2

					color: "#e9e9e9"

					// round edges
					radius: 10

					Text {
						id: buttonText
						anchors.centerIn: parent
						font.pixelSize: 18
						color: "black"
					}

					MouseArea {
						id: mouseArea
						anchors.fill: parent
						hoverEnabled: true
						onClicked: button.clicked()
						onPressed: button.opacity = 0.5
						onReleased: button.opacity = 1
					}
				}
			\endqml
			
			
			
	\chapter TODO
		
		
*/